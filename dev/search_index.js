var documenterSearchIndex = {"docs":
[{"location":"#CloudQSim.jl","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"","category":"section"},{"location":"","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"Documentation for CloudQSim.jl package","category":"page"},{"location":"#Usage","page":"CloudQSim.jl","title":"Usage","text":"","category":"section"},{"location":"","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"To start simulating on the cloud, you will need:","category":"page"},{"location":"","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"Hostname and port of the server. cloudqs.lykov.tech:7700 is the demo server\nCLODUQS_TOKEN - authorization token to run tasks\nA Bloqade.jl hamiltonian\nA set of observables to measure. See observables","category":"page"},{"location":"","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"Please refer to cloud_simulate function for the main API.","category":"page"},{"location":"","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"CloudQSim","category":"page"},{"location":"#CloudQSim","page":"CloudQSim.jl","title":"CloudQSim","text":"Cloud simulation of quantum evolution using Bloqade.jl\n\n\n\n\n\n","category":"module"},{"location":"#Module-Index","page":"CloudQSim.jl","title":"Module Index","text":"","category":"section"},{"location":"","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"Modules = [CloudQSim]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"#observables","page":"CloudQSim.jl","title":"Creating observables for simulation","text":"","category":"section"},{"location":"","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"The default format for observables is a diagonal observable, which is represented by a vector where each element represents the observable value for each corresponding state.","category":"page"},{"location":"","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"While a general observable may be to expensive to send, most non-diagonal observables can be represented as a sum of local terms.","category":"page"},{"location":"","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"The following definition of observables describes how to specify such set of observables.","category":"page"},{"location":"#Using-observables","page":"CloudQSim.jl","title":"Using observables","text":"","category":"section"},{"location":"","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"The observable expression is defined as a sum of local terms applied to different qubits.","category":"page"},{"location":"","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"Create definitions of local terms\nApply the local terms to qubits and add to the sum","category":"page"},{"location":"","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"Note that one can use any local observable as defined by matrix or n-dimensional array.","category":"page"},{"location":"","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"Example:","category":"page"},{"location":"","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"obs = CloudQSObservable()\nX = define_operator!(obs, [[0, 1], [1, 0]], nqubits=1)\nXX = define_operator!(obs, ..., nqubits=2)\n\nset_sum!(obs, X[0], X[1], X[2], XX[0, 2], XX[0, 1])\n\nres = cloud_simulate(hams, obs, clconf)","category":"page"},{"location":"","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"Currently, the only way to define a local operator is to provide the full matrix. In other words, one has to obtain the matrix by using for example, Yao:","category":"page"},{"location":"","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"using Yao\nXX_mat = mat(kron(X for _ in 1:2))","category":"page"},{"location":"","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"It future, this package may provide a more native way to construct observables in a way QSpin does it.","category":"page"},{"location":"#Data-structure","page":"CloudQSim.jl","title":"Data structure","text":"","category":"section"},{"location":"","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"This is the string that will be sent over to the server:","category":"page"},{"location":"","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"{\n    defs: {\n        \"X\": ndarray\n        \"XX\": ndarray\n        },\n    sum_terms: [\n        {label: \"X\", qubits: [0]},\n        {label: \"X\", qubits: [1]},\n        {label: \"X\", qubits: [2]},\n        {label: \"XX\", qubits: [0, 2]},\n        {label: \"XX\", qubits: [0, 1]},\n    ]\n}","category":"page"},{"location":"#Detailed-API","page":"CloudQSim.jl","title":"Detailed API","text":"","category":"section"},{"location":"","page":"CloudQSim.jl","title":"CloudQSim.jl","text":"Modules = [CloudQSim]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"#CloudQSim.CloudConfig","page":"CloudQSim.jl","title":"CloudQSim.CloudConfig","text":"Configuration for cloud simulation servers.\n\nFields\n\naddrs: Hosts to connect to\nports: Ports to use \nworker_counts: Number of workers on each server to use in load balancing\n\nExample\n\njulia> clconf = CloudConfig()\njulia> add_server!(clconf, \"cloudqs.lykov.tech\", 7700)\n\n\n\n\n\n","category":"type"},{"location":"#CloudQSim.CloudQSimTask","page":"CloudQSim.jl","title":"CloudQSim.CloudQSimTask","text":"Simple wrapper for cloud server task\n\n\n\n\n\n","category":"type"},{"location":"#CloudQSim.cloud_simulate-Tuple{AbstractVector, Int64, Vector{<:Vector}, CloudConfig}","page":"CloudQSim.jl","title":"CloudQSim.cloud_simulate","text":"Run quantum evolution of multiple Hamiltonians in the cloud.\n\nArguments\n\nhamiltonian::Vector: List of Hamiltonians\ntime_points::Int: How many evaluations of observables to do   throughout the simulation\nobservables::Vector{<:Vector}: List of observables to evaluate\nsubspace_radius::Float64=0.: Radius of the subspace to use for   the Bloqade subspace evolution\n\nReturns\n\nresults::Array: Array of results, with dimensions   (hamiltonians, time_points, observables)\n\n\n\n\n\n","category":"method"},{"location":"#CloudQSim.get_last_meta-Tuple{}","page":"CloudQSim.jl","title":"CloudQSim.get_last_meta","text":"Get metadata about the last simulation, such as time spent in network, parsing results, etc.\n\n\n\n\n\n","category":"method"},{"location":"#CloudQSim.split_task-Tuple{CloudQSim.CloudQSimTask, Vector{Int64}}","page":"CloudQSim.jl","title":"CloudQSim.split_task","text":"Split one CloudQSimTask into many for balancing of jobs betwen worker     servers\n\n\n\n\n\n","category":"method"}]
}
